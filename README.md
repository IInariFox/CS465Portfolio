The frontend development approaches shared some similarities but also exhibited significant differences. Each of them incorporated static HTML and CSS to some extent. Express development and the SPA were more alike compared to static HTML or JavaScript development. Both Express and the SPA dynamically constructed pages based on the required content, but they employed distinct methodologies.
In Express, numerous pages featured common elements and repeated content. For instance, the header and footer were shared across multiple pages, and list-based pages contained repetitive content due to the consistent layout of list items. Express utilized the database to supply data, employed handlebars to format the content, and employed loops where necessary to populate the pages. This approach facilitated easier page loading and streamlined the editing process for common elements. In contrast, when working with a purely static HTML site, modifying the header or navbar would involve editing each HTML file that contains those elements. On sites with numerous pages, this can become cumbersome, requiring multiple edits for even minor changes. However, with Express, editing the header handlebar file suffices, as it is loaded from a single source during page loads.
Moving on to the SPA, the key difference lies in its treatment of multiple pages. The SPA loads the entire page, including HTML, CSS, and images, during the initial page load. Subsequently, sections of the page are dynamically rewritten as the user navigates, leveraging a router similar to Express. Rather than loading entirely new pages, the SPA retrieves and updates specific sections of the page using database API calls. This approach enhances navigation speed, provides a smoother user experience, and reduces server load.
Regarding the choice of a NoSQL MongoDB database for the backend, several factors influenced our decision. Firstly, MongoDB's flexible schema allowed us to define parameters without strict requirements. We could also create our own simplified schema and index based on specific parameters. Moreover, MongoDB's use of JavaScript aligned seamlessly with the rest of the MEAN stack, enabling JavaScript-based coding across the database, backend, and frontend. MongoDB was also quick to set up, easy to host, and integrated well with the other components of the MEAN stack. For example, instead of using lengthy SQL commands like "SELECT * FROM trips" or "SELECT * FROM trips WHERE code = $code," we could use the simpler syntax "db.trips.find({})" to retrieve all trips or "db.trips.find({"code": "$code"})" to fetch an individual trip. This syntax harmonized with the MEAN stack's overall structure and provided improved manageability.

JSON is closely tied to frontend development since JavaScript objects are used to hold JSON data and manipulate it. In our project, for example, we had trips that contained information such as image names, trip names, descriptions, and more. This data was transmitted to the frontend in JSON format. The frontend then converted it into JavaScript objects called "trips" and utilized the object properties (e.g., trip.name, trip.image, trip.description) to populate HTML fields and display the data to the end user. In a similar manner, JSON is relevant to the backend, especially when using MongoDB. MongoDB stores objects in BSON, which is similar to JSON and facilitates smooth conversion. The frontend can send JSON data to MongoDB for creating, updating, or deleting records, as well as for retrieving information using read functions. The backend leverages JSON to handle the database calls and responses.
Regarding instances in the full stack process where code was refactored to enhance functionality and efficiency, one such example is the trips page. Initially, it was static HTML. However, it was refactored to incorporate handlebars and static JSON data without involving the database. This improvement in user interface development was achieved by reducing the amount of HTML code required for each trip item. Instead of duplicating about 5 or 6 lines of HTML code per trip, we utilized a {{#each trips}} and {{/each}} tag to enclose the HTML block and manipulated it accordingly. This not only streamlined development but also minimized the potential for errors. By eliminating the need to copy and paste multiple lines of HTML for each new trip, the likelihood of missing an edit, such as the correct "a href" tag for the corresponding trip, was significantly reduced. The use of handlebars and static data contributed to these improvements. Subsequently, further refactoring was performed to integrate the database. This enhanced efficiency by enabling the creation of easy-to-use functions for creating and editing data, ensuring controlled management with minimal room for user errors.
Reusable UI components offer several benefits. They reduce code clutter, minimize the amount of manual coding required, and decrease the chances of errors by reducing redundant code. By creating reusable UI components, developers can save time and effort by reusing code snippets or modules throughout the project, enhancing development efficiency and maintainability.

In the project, we primarily utilized console log messages, status codes, and test execution with mock data using Postman or the actual site for testing purposes. The status codes provided insights into the encountered issues, while console log messages helped pinpoint specific problem areas within the code. For instance, during the login function, I incorporated multiple console log messages to identify a bug in the setPassword function. By logging each step of the login process, I noticed that the expected "password okay" log never appeared. This helped me narrow down and rectify the issue.
In terms of API methods, our understanding encompassed GET, POST, PUT, and DELETE, which are facilitated by HTML operations. The GET method initiates a read call to the database, while the POST method triggers a create call. The PUT method enables an edit call, and the DELETE method performs a delete call. Ensuring the security of endpoints is paramount in full-stack development. In our application, we protected sensitive endpoints (POST and PUT) by implementing a check to verify if the user was logged in. However, we overlooked securing the registration process, allowing anyone to register and subsequently perform unauthorized POST or PUT requests. This aspect needs to be addressed in future versions of the site. Security holds significant importance in modern web projects and requires careful consideration and planning.

I am for the most part, glad it's over, but certainly open to learning more. I think that full-stack development as a skill is becoming less and less important with the rise of AI. I think front-end development will be close to irrelevant while the backend will be the main focus for new career opportunities and growth. 
